# 19, 使用WeBASE-Front快速开发springboot项目并使用javaSdk解析合约事件
作者: 深职院-符博<br>
本文内容: 使用WeBASE-Front快速开发springboot项目并使用javaSdk解析合约事件

----------------------------------------

# 使用说明
需提前在本地搭建一条4节点的FISCO-BCOS链 <br>官方文档教程: https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/installation.html<br>
需提前搭建好WeBASE-Front中间件 <br> 官方文档教程: https://webasedoc.readthedocs.io/zh_CN/latest/docs/WeBASE-Front/install.html

# 1, 做好上述准备后,在浏览器中访问 WeBASE-Front
![image](https://user-images.githubusercontent.com/103564714/163139344-af2beea2-31c8-45ef-8d92-1966b0240cc1.png)

# 2, 编写智能合约 本文采用最简单的hello-world进行教学 并定义了一个update事件 当我们调用set方法时会触发

```
pragma solidity ^0.5.2;

contract HelloWorld {
    string name;
    
    event update (
        string name
    );

    constructor() public {
        name = "Hello, World!";
    }

    function get() public view returns (string memory) {
        return name;
    }

    function set(string memory n) public {
        name = n;
        emit update(n);
    }
    
}
```

# 3，编译部署后点击导出java项目并输入channelPort，选择测试用户和要导出的合约
![image](https://user-images.githubusercontent.com/103564714/185935321-a43ac5b1-6239-430c-8abe-08ab71d08aa3.png)
![image](https://user-images.githubusercontent.com/103564714/185935538-a19efe57-02e6-44d8-b53e-a7ad1559ff38.png)


# 4, 导出解压后在idea打开项目, 项目依赖管理用的是gradle 我的gradle版本为6.1.1 jdk版本为11 依赖管理报错的同学可以参考一下我的版本
## 这里我简要的说明了一些基本的包和类的作用，记得将证书放到conf文件里
![image](https://user-images.githubusercontent.com/103564714/185937630-dcef7ac4-e2f3-4570-b22d-3e806d518bb6.png)
## 然后配置好我们的application
![image](https://user-images.githubusercontent.com/103564714/185939526-53146510-65f1-4b35-b669-e4d63af40302.png)<br>
## 可以看到我们的service里已经封装好了两个方法 set方法的入参就为上面帮我们封装好的bo 我们可以直接基于脚手架去调用链上合约 但我下面将用原生的方法调用
![image](https://user-images.githubusercontent.com/103564714/185940930-cbf45886-6ba2-45fd-995f-151cc63c1aa0.png)




# 5, 再写测试接口前我们现在resource目录下创建config-example.toml文件 大家只需要在[network]改成自己的节点地址即可 有几个节点就写几个
```PowerShell
[cryptoMaterial]
certPath = "conf"                           # The certification path

# The following configurations take the certPath by default if commented
# caCert = "conf/ca.crt"                    # CA cert file path
# If connect to the GM node, default CA cert path is ${certPath}/gm/gmca.crt

# sslCert = "conf/sdk.crt"                  # SSL cert file path
# If connect to the GM node, the default SDK cert path is ${certPath}/gm/gmsdk.crt

# sslKey = "conf/sdk.key"                   # SSL key file path
# If connect to the GM node, the default SDK privateKey path is ${certPath}/gm/gmsdk.key

# enSslCert = "conf/gm/gmensdk.crt"         # GM encryption cert file path
# default load the GM SSL encryption cert from ${certPath}/gm/gmensdk.crt

# enSslKey = "conf/gm/gmensdk.key"          # GM ssl cert file path
# default load the GM SSL encryption privateKey from ${certPath}/gm/gmensdk.key

[network]
peers=["127.0.0.1:20200", "127.0.0.1:20201", "127.0.0.1:20202", "127.0.0.1:20203"]    # The peer list to connect


# AMOP configuration
# You can use following two methods to configure as a private topic message sender or subscriber.
# Usually, the public key and private key is generated by subscriber.
# Message sender receive public key from topic subscriber then make configuration.
# But, please do not config as both the message sender and the subscriber of one private topic, or you may send the message to yourself.

# Configure a private topic as a topic message sender.
# [[amop]]
# topicName = "PrivateTopic"
# publicKeys = [ "conf/amop/consumer_public_key_1.pem" ]    # Public keys of the nodes that you want to send AMOP message of this topic to.

# Configure a private topic as a topic subscriber.
# [[amop]]
# topicName = "PrivateTopic"
# privateKey = "conf/amop/consumer_private_key.p12"         # Your private key that used to subscriber verification.
# password = "123456"


[account]
keyStoreDir = "account"         # The directory to load/store the account file, default is "account"
# accountFilePath = ""          # The account file path (default load from the path specified by the keyStoreDir)
accountFileFormat = "pem"       # The storage format of account file (Default is "pem", "p12" as an option)

# accountAddress = ""           # The transactions sending account address
# Default is a randomly generated account
# The randomly generated account is stored in the path specified by the keyStoreDir

# password = ""                 # The password used to load the account file

[threadPool]
# channelProcessorThreadSize = "16"         # The size of the thread pool to process channel callback
# Default is the number of cpu cores

# receiptProcessorThreadSize = "16"         # The size of the thread pool to process transaction receipt notification
# Default is the number of cpu cores

maxBlockingQueueSize = "102400"             # The max blocking queue size of the thread pool

```


# 6，准备就绪后 下面就是我们的测试接口，相关的注释我已经写好啦

``` JAVA
@RestController
@RequestMapping("/hello")
public class HelloWorldController {

    // 获取合约abi
    public static final String ABI = org.example.Vaccine.utils.IOUtil.readResourceAsString("abi/HelloWorld.abi");

    // 获取配置文件路径
    public final String configFile = HelloWorldController.class.getClassLoader().getResource("config-example.toml").getPath();

    @GetMapping("/{input}")
    private CommonResponse eventTest(@PathVariable String input) throws Exception {

        BcosSDK sdk = BcosSDK.build(configFile);

        // 为群组1初始化client
        Client client = sdk.getClient(Integer.valueOf(1));

        // 获取密钥
        CryptoKeyPair keyPair = client.getCryptoSuite().createKeyPair();

        // 将客户端 密钥对 abi和bin文件路径传入创建AssembleTransactionProcessor对象
        AssembleTransactionProcessor processor = TransactionProcessorFactory.createAssembleTransactionProcessor(
                client,
                keyPair,
                "src/main/resources/abi",
                "src/main/resources/bin");

        // 获取当前群组对应的密码学接口
        CryptoSuite cryptoSuite = client.getCryptoSuite();
        // 构造TransactionDecoderService实例，传入是否密钥类型参数。
        TransactionDecoderInterface decoder = new TransactionDecoderService(cryptoSuite);

        // 封装合约入参
        List paramList = new ArrayList();
        paramList.add(input);

        // 发送交易 合约名称 合约地址 方法名称 方法参数
        TransactionResponse transactionResponse = processor.sendTransactionAndGetResponseByContractLoader(
                "HelloWorld",
                "0x926bcd689bd3576c9be49f3c1993468ee835a269",
                "set",
                paramList);

        // 获得事件的返回值 key是事件名称
        Map<String, List<List<Object>>> stringListMap = decoder.decodeEvents(ABI, transactionResponse.getTransactionReceipt().getLogs());

        // 获取值
        List<List<Object>> update = stringListMap.get("update");
        List<Object> objects = update.get(0);
        String event = objects.get(0).toString(); // event就是事件返回的值
        System.out.println(event);
        return CommonResponse.ok(event);
    }
}

```


# 7, 然后用postman测试一下
![image](https://user-images.githubusercontent.com/103564714/196128292-3a4efed5-5d37-4b99-b208-13038c3b7c3a.png)

## 然后看看我们的控制台，事件已经被成功解析。
![image](https://user-images.githubusercontent.com/103564714/196128799-9bc733ae-4089-48c9-a8a4-72bbac6a00e5.png)





